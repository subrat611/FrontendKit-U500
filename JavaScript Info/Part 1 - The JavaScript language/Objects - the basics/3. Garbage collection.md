üí° _Memory management in JavaScript is automatic. The garbage collector removes unused objects from memory based on reachability._
## 1. Concept Overview

- **Garbage Collection (GC)**: Automatic memory management that frees up memory by removing unreachable objects.
- **Why?** 
	- Prevents memory leaks, improves performance, and ensures efficient resource use.
- **How?** 
	- JS engine marks objects as "reachable" or "unreachable" and removes the latter.
## 2. Key Concepts

### Reachability

- The main concept of memory management in JavaScript is¬†_reachability_.
- **Reachable values**: Objects that can still be accessed.

1. There‚Äôs a base set of inherently reachable values, that cannot be deleted for obvious reasons.

	**For instance:**
    - The currently executing function, its local variables and parameters.
    - Other functions on the current chain of nested calls, their local variables and parameters.
    - Global variables.
    - (there are some other, internal ones as well)
    These values are called¬†_roots_.
    
- **Root values**:
    - Global variables
    - Local function variables
    - Active function call stack

- Any other value is considered reachable if it‚Äôs reachable from a root by a reference or by a chain of references.
- For instance, if there‚Äôs an object in a global variable, and that object has a property referencing another object,¬†_that_¬†object is considered reachable. And those that it references are also reachable. Detailed examples to follow

- There‚Äôs a background process in the JavaScript engine that is called¬†[garbage collector](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)). It monitors all objects and removes those that have become unreachable.

### Object References & Garbage Collection
#### Example 1: Losing Reference

```js
let user = { name: "John" }; // Object is reachable
user = null; // John object is now unreachable
```

‚è© **Effect**: The GC will remove the `{ name: "John" }` object since no reference exists.

![[../../assets/Pasted image 20250121215913.png]]
#### Example 2: Multiple References

```js
let user = { name: "John" };
let admin = user; // Both user & admin reference the same object

user = null; // Object is still accessible via admin
admin = null; // Now it's garbage collected
```
## 3. Garbage Collection Algorithm
### Mark-and-Sweep Algorithm

1. **Mark Phase**: The GC starts from root objects and marks all reachable objects.
2. **Sweep Phase**: Removes unmarked (unreachable) objects from memory.
#### Example: Mark-and-Sweep Process

```js
let family = {
  father: { name: "John" },
  mother: { name: "Ann" }
};

delete family.father; // John is still reachable from mother
delete family.mother; // Now John is unreachable and will be garbage collected
```

üìå **Key Takeaway**: _Only incoming references matter. If an object has no incoming reference from a root, it becomes unreachable and is removed._
## 4. Advanced Garbage Collection Strategies
### Optimizations Used in Modern JS Engines

| Optimization                | Description                                                                               |
| --------------------------- | ----------------------------------------------------------------------------------------- |
| **Generational Collection** | Separates short-lived and long-lived objects. Short-lived objects are cleared frequently. |
| **Incremental Collection**  | Divides GC into smaller tasks to prevent performance lags.                                |
| **Idle-time Collection**    | Runs GC when CPU is idle to avoid blocking execution.                                     |
**Why it Matters?**  

These optimizations ensure GC runs efficiently without slowing down your JavaScript application.
## 5. Interview Pitfalls & Best Practices
### **Common Mistakes**

‚ùå **Memory Leaks Due to Closures**

```js
function createClosure() {
  let largeArray = new Array(1000000); // Huge memory allocation
  return function() {
    console.log(largeArray.length); // Closure retains largeArray in memory
  };
}
let leakyFunction = createClosure();
```

‚úÖ **Fix**: Explicitly set `largeArray = null` when no longer needed.

‚ùå **Event Listener Memory Leak**

```js
document.getElementById("btn").addEventListener("click", function() {
  console.log("Clicked!");
});
```

‚úÖ **Fix**: Always remove event listeners.

```js
btn.removeEventListener("click", handler);
```
## 6Ô∏è. Quick Revision Cheatsheet

| Concept                 | Key Takeaway                                                        |
| ----------------------- | ------------------------------------------------------------------- |
| **Garbage Collection**  | Automatic memory cleanup in JS.                                     |
| **Reachability**        | Objects are garbage collected if they are not reachable from roots. |
| **Mark-and-Sweep**      | GC marks reachable objects, sweeps unreachable ones.                |
| **Common Memory Leaks** | Closures, Event Listeners, Global Variables.                        |
| **Optimizations**       | Generational, Incremental, Idle-time Collection.                    |
