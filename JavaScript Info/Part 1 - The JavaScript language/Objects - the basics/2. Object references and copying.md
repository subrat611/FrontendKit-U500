## 1. Objects vs Primitives

- Difference between Object and Primitives is that 
	- Objects are stored and copied **“by reference”**.
	- Primitive values: strings, numbers, booleans, etc  are always copied **“as a whole value”**.

```js
let message = "Hello!";
let phrase = message;
```
 
 As a result we have two independent variables, each one storing the string `"Hello!"`.

**A variable assigned to an object stores not the object itself, but its “address in memory” – in other words “a reference” to it.**

```js
let user = {
  name: "John"
};
```

- The object is stored somewhere in memory (at the right of the picture), while the `user` variable (at the left) has a “reference” to it.
- When we perform actions with the object, e.g. take a property `user.name`, the JavaScript engine looks at what’s at that address and performs the operation on the actual object.

**When an object variable is copied, the reference is copied, but the object itself is not duplicated.**

```js
let user = { name: "John" };
let admin = user; // copy the reference
```

```js
let user = { name: 'John' };
let admin = user;
admin.name = 'Pete'; // changed by the "admin" reference
alert(user.name); // 'Pete', changes are seen from the "user" reference
```

- `user` and `admin` **both reference the same object** in memory.
- Changing `admin.name` affects `user.name`.
## 2. Comparison of Objects

- Two objects are equal only if they reference the same object.

```js
let a = {};
let b = a; // Both reference the same object
console.log(a == b);  // true
console.log(a === b); // true
```

- Different objects are not equal, even if they have identical properties.

```js
let a = {};
let b = {}; // Two independent objects
console.log(a == b);  // false
console.log(a === b); // false
```
## 3. Modifying const Objects

- A const object can have its properties modified, but it cannot be reassigned.

```js
const user = { name: "John" };
user.name = "Pete"; // Works fine
// user = {}; // ❌ ERROR: Assignment to constant variable
```
## 4. Cloning and Merging Objects

Shallow Cloning (Only Copies Top-Level Properties)

1️⃣ Using a loop

```js
let user = { name: "John", age: 30 };
let clone = {};

for (let key in user) {
  clone[key] = user[key];
}

clone.name = "Pete";
console.log(user.name); // "John" (unchanged)
```

2️⃣ Using Object.assign()

```js
let user = { name: "John" };
let clone = Object.assign({}, user);
```

- Copies all properties from `user` into `clone`.

3️⃣ Merging Objects with Object.assign()

```js
let user = { name: "John" };
let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

Object.assign(user, permissions1, permissions2);
console.log(user); // { name: "John", canView: true, canEdit: true }
```

- If a property **already exists**, it **gets overwritten**.

```js
Object.assign(user, { name: "Pete" });
console.log(user.name); // "Pete"
```

There are also other methods of cloning an object, e.g. using the [spread syntax](https://javascript.info/rest-parameters-spread) `clone = {...user}`, covered later in the tutorial.
## 5. Nested Object Cloning (Deep Cloning)

- Problem with `Object.assign()`

```js
let user = {
  name: "John",
  sizes: { height: 182, width: 50 }
};

let clone = Object.assign({}, user);
console.log(user.sizes === clone.sizes); // true (Still references same object)
```

- **Changing `clone.sizes.width` affects `user.sizes.width`!**

**Solution: Deep Cloning with structuredClone()**

```js
let user = {
  name: "John",
  sizes: { height: 182, width: 50 }
};

let clone = structuredClone(user);

console.log(user.sizes === clone.sizes); // false (Independent objects)

user.sizes.width = 60;
console.log(clone.sizes.width); // 50 (Remains unchanged)
```

**Cloning Objects with Circular References**

```js
let user = {};
user.me = user; // Circular reference

let clone = structuredClone(user);
console.log(clone.me === clone); // true (Correctly clones circular structure)
```

- `structuredClone()` **supports circular references.**

**Limitations of structuredClone()**

- **Functions cannot be cloned**

```js
structuredClone({ f: function() {} }); // ❌ Error
```

- **For advanced cases**, use `_.cloneDeep(obj)` from **Lodash**.
## 6. Summary

✅ **Objects are copied by reference**, meaning variables store **memory addresses**, not actual values.  
✅ **Primitive values are copied directly**, creating independent copies.  
✅ **To copy objects**, use:
- **Shallow copy**: `Object.assign({}, obj)` (nested objects still reference the same memory).
- **Deep copy**: `structuredClone(obj)` or `_.cloneDeep(obj)`.  
    ✅ **Modifying a `const` object’s properties is allowed**, but reassignment is not.  
    ✅ **Comparing objects checks references, not values** (`{}` !== `{}`).